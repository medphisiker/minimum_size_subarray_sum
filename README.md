# 209. Минимальный размер подмассива с заданной суммой

## Описание

Эта задача с `LeetCode` ([ссылка](https://leetcode.com/problems/minimum-size-subarray-sum/?envType=study-plan-v2&envId=top-interview-150)).


Дано:
- массив положительных целых чисел `nums`
- положительное целое число `target`

Верните:
- минимальную длину подмассива, сумма которого больше или равна `target`
- если такого подмассива нет, верните `0` вместо этого

## Примеры

### Пример 1
Входные данные: 
```
target = 7, nums = [2,3,1,2,4,3]
```
Выходные данные:
```
2
```

**Объяснение:** Подмассив `[4,3]` имеет минимальную длину при заданных ограничениях задачи.

### Пример 2
Входные данные:
```
target = 4, nums = [1,4,4]
```
Выходные данные:
```
1
```

### Пример 3
Входные данные:
```
target = 11, nums = [1,1,1,1,1,1,1,1]
```
Выходные данные:
```
0
```

## Ограничения

- `1 <= target <= 10^9`
- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^4`

## Дополнительное задание

Если вы уже решили задачу за `O(n)`, попробуйте реализовать другое решение со сложностью времени `O(n log(n))`.

## Решение

### Основной подход: Sliding Window

Решение использует паттерн `скользящего окна` (`sliding window`). Подвид `сжимающееся окно` (`shrinking window`) с переменным размером окна для эффективного поиска минимального подмассива с суммой, большей или равной заданному порогу `target`.

Алгоритм работает следующим образом:
1. Используются два указателя (`left` и `right`), определяющие текущее "окно" - подмассив в исходном массиве.
2. Правый указатель (`right`) перемещается вправо, расширяя окно и увеличивая сумму элементов в нем.
3. Когда сумма элементов в окне становится больше или равна `target`:
   - Обновляется минимальная длина подмассива, если текущая длина окна меньше ранее найденной.
   - Левый указатель (`left`) перемещается вправо, сужая окно и уменьшая сумму, чтобы попытаться найти более короткий подходящий подмассив.
4. Процесс продолжается до тех пор, пока правый указатель не пройдет весь массив.

### Временная и пространственная сложность

- **Временная сложность:** O(n), где n - количество элементов в массиве. В худшем случае каждый элемент массива будет рассмотрен дважды (один раз правым указателем и один раз левым указателем).
- **Пространственная сложность:** O(1), так как алгоритм использует только константное количество дополнительной памяти.

### Реализация

Реализация находится в файле [`solution.py`](solution.py) и включает подробные комментарии, объясняющие каждый шаг алгоритма.